import math
import decimal
from decimal import Decimal
from fractions import Fraction
from numbers import Number
from numbers import Rational
from collections import abc
import itertools as it
import functools as ft
import operator
import typing

import gl2z
import prime_numbers
from quadratic_fields import RealQuadraticNumber, RealQuadraticField
import binary_quadratic_forms



class NonzeroIdeal(abc.Container):
    """
    Nonzero ideal in the ring of integers ğ“_K of K=ğ(âˆšd).

    Henri Cohen, A Course in Computation Algebraic Number Theory, Graduate Texts in Mathematics, Volume 138, Springer, 1996.

    p. 166:
    Theorem 4.4.2. The ring ğ™_K is a free Z-module of rank n=deg(K). This is true more generally for any non-zero ideal of
    ğ™_K.

    p. 166:
    Definition 4.4.3. A ğ™-basis of the free module ğ™_K will be called an integral
    basis of K. The discriminant of an integral basis is independent of the choice
    of that basis, and is called the discriminant of the field K and is denoted by
    d(K).

    Anthony W. Knapp, Advanced Algebra, Digital Second Edition, 2016.
    Chapter I, Section 7, "Relationship of Quadratic Forms to Ideals", pp. 38-50.

    p. 44:
    Lemma 1.19.
    (a) If a â‰  0 and b' are integers such that a divides N(b' + Î´) in ğ™, then
    (a, b' + Î´) = âŸ¨a, b' + Î´âŸ© in the sense that the free abelian subgroup of R generated
    by a and b' + Î´ coincides with the ideal generated by a and b' + Î´.
    (b) If I is any nonzero ideal in R, then I is of the form I = âŸ¨a, râŸ© for some
    integer a > 0 and some r in R.
    """

    __slots__ = ["d", "a", "r"]

    @staticmethod
    def orientation(r1: RealQuadraticNumber, r2: RealQuadraticNumber) -> RealQuadraticNumber:
        if not (r1.is_integral and r2.is_integral):
            raise ValueError(f"{r1=} and {r2=} must be integral elements of ğ(âˆšd).")
        if r1.d != r2.d:
            raise ValueError(f"{r1=} and {r2=} must belong to same ring of integers ğ“_ğ(âˆšd).")
        return r1 * r2.conjugate() - r1.conjugate() * r2
    
    @staticmethod
    def coords_Z_in_1_omega(r: RealQuadraticNumber) -> tuple[int, int]:
        """Return the (ğ™,ğ™)â€‘coordinates of an integral element r in the basis (1, Ï‰)."""
        if not r.is_integral:
            raise ValueError(f"{r} must belong to ring of integers ğ“_ğ(âˆšd).")
        if r.d % 4 == 1:         # fundamental discriminant of the form 1 mod 4
            s = r.x - r.y        # integer
            t = 2 * r.y          # integer
        else:                    # d â‰¡ 2,3  (basis is already (1, âˆšd))
            s = r.x
            t = r.y
        if Fraction(s).denominator != 1 or Fraction(t).denominator != 1:
            raise ValueError("nonâ€‘integral coordinates â€“ logic error")
        return int(s), int(t)

    def __init__(self, a: RealQuadraticNumber | Rational, r: RealQuadraticNumber) -> None:
        """
        Return (a, r) with a âˆˆ Z_{>0}, r = b0 + Î´ and gcd(a, b0) = 1,
        oriented so that (r / a) has positive imaginary part.
        """
        d = r.d
        if isinstance(a, Rational):
            a = RealQuadraticNumber(d, a, 0)
        if type(self).orientation(a, r) == 0:
            raise ValueError(f"({a}, {r}) must have nonzero orientation.")

        # put a, r into the integral basis (1, Ï‰)
        omega  = RealQuadraticField(d).omega
        x1, y1 = type(self).coords_Z_in_1_omega(a)
        x2, y2 = type(self).coords_Z_in_1_omega(r)
        m  = gl2z.M2Z(x1, x2, y1, y2) # 2Ã—2 integer matrix

        _, H  = gl2z.hnf_2x2(m.transpose())
        a, b0 = H.a11, H.a12
        if a < 0:
            a, b0 = -a, -b0

        g = math.gcd(a, b0)
        if b0 != 0 and g > 1:
            a //= g
            b0 //= g     

        # unique representative 0 â‰¤ b0 < a
        b0 %= a                          
        r = b0 + omega # b0 + Î´, Î´ = Ï‰ âˆ’ Â½tr Ï‰

        self.d = d
        self.a = RealQuadraticNumber(d, a, 0)
        self.r = r

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self.a}, {self.r})"
    
    def __hash__(self) -> int:
        return hash((self.a, self.r))

    @property
    def oriented_volume(self) -> RealQuadraticNumber:
        return type(self).orientation(self.a, self.r)
    
    @property
    def volume(self) -> RealQuadraticNumber:
        if self.oriented_volume < 0:
            return -self.oriented_volume
        return self.oriented_volume

    @property
    def D(self: typing.Self) -> int:
        """
        Discriminant.
        Henri Cohen, A Course in Computation Algebraic Number Theory, Graduate Texts in Mathematics, Volume 138, Springer, 1996.
        p. 167:

        Proposition 4.4.5. The algebraic numbers ğ›¼1, ..., ğ›¼n form an integral basis
        if and only if they are algebraic integers and if d(ğ›¼1, ..., ğ›¼n) = d(K), where
        d(K) is the discriminant of K.
        """
        return self.d if self.d % 4 == 1 else 4 * self.d

    @property
    def norm(self) -> int:
        d = self.d
        if d % 4 == 1: # D = d
            D_sqrt = RealQuadraticNumber(d, 0, 1)
            return int(self.volume / D_sqrt)
        elif d % 4 in [2, 3]: # D = 4d
            D_sqrt = RealQuadraticNumber(d, 0, 2)
            return int(self.volume / D_sqrt)        


    def __contains__(self, item: RealQuadraticNumber | Rational) -> bool:
        """
        a1 * r1 + a2 * r2 = r
        a1(x1 + y1âˆšd) + a2(x2 + y2âˆšd) = x + yâˆšd
        a1x1 + a2x2 + (a1y1 + a2y2)âˆšd = x + yâˆšd
        x1a1 + x2a2 = x
        y1a1 + y2a2 = y

        Cramer's rule:
        a1 = (x * y2 - x2 * y) / (x1y2 - x2y1) 
        a2 = (x1 * y - x * y1) / (x1y2 - x2y1)
        """
        if isinstance(item, Rational):
            item = RealQuadraticNumber(self.d, item, 0)
        if not item.is_integral:
            raise ValueError(f"{item=} must be an integral element of ğ(âˆšd).")
        a, r = self.a, self.r
        ax, ay, rx, ry, x, y = a.x, a.y, r.x, r.y, item.x, item.y
        D = ax * ry - rx * ay # nonzero by nonzero orientation

        a1 = Fraction(x * ry - rx * y, D)
        a2 = Fraction(ax * y - x * ay, D)
        if a1.denominator == 1 and a2.denominator == 1:
            return True
        return False

    def bqf(self) -> binary_quadratic_forms.IndefiniteBQF:
        """
        Anthony W. Knapp, Advanced Algebra, Digital Second Edition, 2016.
        Chapter I, Section 7, "Relationship of Quadratic Forms to Ideals", pp. 38-50.
        Return the primitive binary quadratic form that Knapp (Ch. I Â§7, pp 42-43)
        attaches to the ideal I = âŸ¨r1, r2âŸ©.

            a =  N(r1) / N(I)
            b =  Tr(r1 * ğœ(r2)) / N(I)
            c =  N(r2) / N(I)

        The trace makes b rational; we then clear any remaining denominators
        and divide out the overall gcd so that (a,b,c) is primitive.
        """
        a, r = self.a, self.r
        N_I = self.norm

        A = Fraction(a.norm, N_I)
        B = Fraction((a * r.conjugate()).trace, N_I)
        C = Fraction(r.norm, N_I)

        denominator_lcm = math.lcm(A.denominator, B.denominator, C.denominator)
        a = (A * denominator_lcm).numerator
        b = (B * denominator_lcm).numerator
        c = (C * denominator_lcm).numerator

        g = math.gcd(a, b, c)

        return binary_quadratic_forms.IndefiniteBQF(a // g, b // g, c // g)

    @classmethod
    def bqf_to_ideal(cls, form: binary_quadratic_forms.IndefiniteBQF) -> typing.Self:
        """
        Invert `NonzeroIdeal.bqf()` for a *primitive* indefinite binary quadratic
        form (a,b,c).

        Let Î” = bÂ²â€‘4ac.  Write Î” = fÂ²Â·Dâ‚€ with Dâ‚€ fundamental and f â‰¥ 1 the
        conductor.  Knapp (Adv. Alg. I.Â§7) attaches to (a,b,c) the ideal

            I = âŸ¨a , râŸ©,â€ƒ r = (âˆ’b + âˆšÎ”)/2  âŠ‚  ğ’ªâ‚–  with  K = â„š(âˆšDâ‚€).

        If g = gcd(a,f) > 1 then âŸ¨a,râŸ© lives only in the order of conductor f;
        we embed it into the maximal order by dividing *both* generators by g.
        Finally we express r in the integral basis (1, Ï‰) and ensure the pair
        (a,bâ‚€+ k Ï‰) is primitive (gcd(a,bâ‚€)=1, 0 â‰¤ bâ‚€ < a).

        The routine returns the canonical `NonzeroIdeal` produced by the public
        constructor, so all orientation/HNF conventions match those of `__init__`.
        """
        a, b        = form.a, form.b
        D           = form.D
        f           = form.conductor                         # Buchmannâ€“Vollmer defn.

        # ---------------------------------------------------------------------
        # 1. Decide the fundamental part Dâ‚€ and the actual quadratic field
        # ---------------------------------------------------------------------
        D0 = D // (f * f)
        if D0 % 4 == 1:                                     # Dâ‚€ = d  (Ï‰ = (1+âˆšd)/2)
            d          = D0
            x_r        = Fraction(-b, 2)                    # xâ€‘coord of r  before /g
            y_r        = Fraction(f,  2)                    # yâ€‘coord of r  before /g
        else:                                               # Dâ‚€ = 4d  (Ï‰ = âˆšd)
            d          = D0 // 4
            x_r        = Fraction(-b, 2)
            y_r        = Fraction(f,  1)

        # ---------------------------------------------------------------------
        # 2. Embed into the maximal order by dividing by g = gcd(a,f)
        # ---------------------------------------------------------------------
        g = math.gcd(a, f)
        if g > 1 and g < a:
            a //= g
            x_r /= g
            y_r /= g

        # ensure a > 0   (negating both generators gives the same lattice)
        if a < 0:
            a   = -a
            x_r = -x_r
            y_r = -y_r

        # ---------------------------------------------------------------------
        # 3. Express r = bâ‚€ + kÂ·Ï‰  with integers bâ‚€,k
        # ---------------------------------------------------------------------
        if d % 4 == 1:
            k  = 2 * y_r                                   # y_r = k/2
            b0 = x_r - k/2
        else:                                              # Ï‰ = âˆšd
            k  = y_r
            b0 = x_r

        if k.denominator != 1 or b0.denominator != 1:
            raise ValueError("Internal error: r not integral after normalisation.")

        k  = int(k)
        b0 = int(b0)

        # ---------------------------------------------------------------------
        # 4. Make (a,bâ‚€) coprime and reduce 0 â‰¤ bâ‚€ < a
        # ---------------------------------------------------------------------
        h = math.gcd(a, b0)
        if b0 != 0 and h > 1:
            a  //= h
            b0 //= h

        b0 %= a # unique representative
        omega   = RealQuadraticField(d).omega
        r_final = RealQuadraticNumber(d, b0, 0) + k * omega

        # ---------------------------------------------------------------------
        # 5. Build the ideal directly, *storing k*, to keep the chosen basis.
        # ---------------------------------------------------------------------
        I     = cls.__new__(cls)
        I.d   = d
        I.a   = RealQuadraticNumber(d, a, 0)
        I.r   = r_final
        return I

    def __eq__(self, other: typing.Self) -> bool:
        return binary_quadratic_forms.IndefiniteBQF.are_equivalent(self.bqf(), other.bqf())

    def __mul__(self, other: typing.Self) -> typing.Self:
        bqf_self, bqf_other = self.bqf(), other.bqf()
        f  = math.lcm(bqf_self.conductor, bqf_other.conductor)
        if bqf_self.conductor != f:
            bqf_self = bqf_self.lift(f // bqf_self.conductor)
        if bqf_other.conductor != f:
            bqf_other = bqf_other.lift(f // bqf_other.conductor)
        return type(self).bqf_to_ideal(bqf_self * bqf_other)
    
    def __rmul__(self, other: typing.Self) -> typing.Self:
        bqf_self, bqf_other = self.bqf(), other.bqf()
        f  = math.lcm(bqf_self.conductor, bqf_other.conductor)
        if bqf_self.conductor != f:
            bqf_self = bqf_self.lift(f // bqf_self.conductor)
        if bqf_other.conductor != f:
            bqf_other = bqf_other.lift(f // bqf_other.conductor)
        return type(self).bqf_to_ideal(bqf_other * bqf_self)
    
    def inverse(self) -> typing.Self:
        bqf = self.bqf()
        bqf_inverse = bqf.inverse()
        inverse_ideal = type(self).bqf_to_ideal(bqf_inverse)
        return inverse_ideal
    
    def __truediv__(self, other: typing.Self) -> typing.Self:
        return self * other.inverse()
    
    def __rtruediv__(self, other: typing.Self) -> typing.Self:
        return other * self.inverse()

    @classmethod
    def make_prime_ideal(cls, d: int, p: int, t_sgn: int = 1) -> typing.Self:
        """
        Henri Cohen, *A Course in Computational Algebraic Number Theory*,
        Prop. 5.1.4, p. 224.

        Let K = â„š(âˆšD) with maximal order ğ’ª_K = â„¤[Ï‰],  Ï‰ = (D + âˆšD)/2.

        (1) (D/p)=0  â†’  p ramifies      (p) = ğ”­Â²,  ğ”­ = âŸ¨p , Ï‰âŸ©
            except p=2 & Dâ‰¡12 (mod 16): ğ”­ = âŸ¨2 , 1+Ï‰âŸ©.

        (2) (D/p)=â€“1 â†’  p is inert    (p) itself is prime: âŸ¨p , p Ï‰âŸ©.

        (3) (D/p)=+1 â†’  p splits     (p)=ğ”­â‚ ğ”­â‚‚ with
            ğ”­â‚ = âŸ¨p , (-b+âˆšD)/2âŸ©,  ğ”­â‚‚ = âŸ¨p , (b+âˆšD)/2âŸ©,
            where bÂ²â‰¡D (mod p).  Choose the sign of b via t_sgn âˆˆ {Â±1}.
        """
        

if __name__ == "__main__":
    d = 19
    q1 = RealQuadraticNumber(d, 2, 2)
    q2 = RealQuadraticNumber(d, 0, 1)
    ideal1 = NonzeroIdeal(q1, q2)
    bqf1 = ideal1.bqf()
    assert NonzeroIdeal.bqf_to_ideal(bqf1) == ideal1

    q1 = RealQuadraticNumber(d, 2, 3)
    q2 = RealQuadraticNumber(d, 0, 2)
    ideal2 = NonzeroIdeal(q1, q2)
    bqf2 = ideal2.bqf()
    assert NonzeroIdeal.bqf_to_ideal(bqf2) == ideal2

    bqf3 = bqf1 * bqf2
    ideal3 = ideal1 * ideal2
    assert NonzeroIdeal.bqf_to_ideal(bqf3) == ideal3
    bqf4 = ideal3.bqf()
    assert binary_quadratic_forms.IndefiniteBQF.are_equivalent(bqf3, bqf4) == True

    d = 17
    q1 = RealQuadraticNumber(d, 3, 2)
    q2 = RealQuadraticNumber(d, 0, 3)
    ideal1 = NonzeroIdeal(q1, q2)
    bqf1 = ideal1.bqf()
    assert NonzeroIdeal.bqf_to_ideal(bqf1) == ideal1

    q1 = RealQuadraticNumber(d, 5, 0)
    q2 = RealQuadraticNumber(d, 0, 5)
    ideal2 = NonzeroIdeal(q1, q2)
    bqf2 = ideal2.bqf()
    assert NonzeroIdeal.bqf_to_ideal(bqf2) == ideal2

    bqf3 = bqf1 * bqf2
    ideal3 = ideal1 * ideal2
    assert NonzeroIdeal.bqf_to_ideal(bqf3) == ideal3
    bqf4 = ideal3.bqf()
    assert binary_quadratic_forms.IndefiniteBQF.are_equivalent(bqf3, bqf4) == True

    d = 17
    q1 = RealQuadraticNumber(d, 3, 0)
    q2 = RealQuadraticNumber(d, 0, 3)
    ideal1 = NonzeroIdeal(q1, q2)
    q1 = RealQuadraticNumber(d, 5, 5)
    q2 = RealQuadraticNumber(d, 0, 5)
    ideal2 = NonzeroIdeal(q1, q2)
    ideal3 = ideal1 * ideal2
    assert ideal3.norm == ideal1.norm * ideal2.norm

    d = 29 # 29 â‰¡ 1 (mod 4)
    ideal_A = NonzeroIdeal(
                RealQuadraticNumber(d, 4, 1), # âŸ¨4 , 1+âˆš29âŸ©   (norm 4)
                RealQuadraticNumber(d, 0, 4))
    assert NonzeroIdeal.bqf_to_ideal(ideal_A.bqf()) == ideal_A

    d = 6 # 6 â‰¡ 2 (mod 4)
    ideal_B = NonzeroIdeal(
                RealQuadraticNumber(d, 3, 1), # âŸ¨3 , 1+âˆš6âŸ©   (norm 3)
                RealQuadraticNumber(d, 0, 3))
    assert NonzeroIdeal.bqf_to_ideal(ideal_B.bqf()) == ideal_B

    d = 19
    I   = NonzeroIdeal(
            RealQuadraticNumber(d, 2, 1),     # âŸ¨2 , 1+âˆš19âŸ©
            RealQuadraticNumber(d, 0, 2))
    P   = I * I.inverse()                       # should be (1)
    assert P.norm == 1
    assert P == NonzeroIdeal(
                RealQuadraticNumber(d, 1, 0),  # âŸ¨1 , âˆš19âŸ©  principal
                RealQuadraticNumber(d, 0, 1))