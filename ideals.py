import math
import decimal
from decimal import Decimal
from fractions import Fraction
from numbers import Number
from numbers import Rational
from collections import abc
import itertools as it
import functools as ft
import operator
import typing

import gl2z
import prime_numbers
from quadratic_fields import RealQuadraticNumber, RealQuadraticField


class NonzeroIdeal(abc.Container):
    """
    Nonzero ideal in the ring of integers ğ“_K of K=ğ(âˆšd).

    Henri Cohen, A Course in Computation Algebraic Number Theory, Graduate Texts in Mathematics, Volume 138, Springer, 1996.

    p. 166:
    Theorem 4.4.2. The ring ğ™_K is a free Z-module of rank n=deg(K). This is true more generally for any non-zero ideal of
    ğ™_K.

    p. 166:
    Definition 4.4.3. A ğ™-basis of the free module ğ™_K will be called an integral
    basis of K. The discriminant of an integral basis is independent of the choice
    of that basis, and is called the discriminant of the field K and is denoted by
    d(K).

    Anthony W. Knapp, Advanced Algebra, Digital Second Edition, 2016.
    Chapter I, Section 7, "Relationship of Quadratic Forms to Ideals", pp. 38-50.

    p. 44:
    Lemma 1.19.
    (a) If a â‰  0 and b' are integers such that a divides N(b' + Î´) in ğ™, then
    (a, b' + Î´) = âŸ¨a, b' + Î´âŸ© in the sense that the free abelian subgroup of R generated
    by a and b' + Î´ coincides with the ideal generated by a and b' + Î´.
    (b) If I is any nonzero ideal in R, then I is of the form I = âŸ¨a, râŸ© for some
    integer a > 0 and some r in R.
    """

    __slots__ = ["d", "a", "r"]


    @staticmethod
    def orientation(r1: RealQuadraticNumber, r2: RealQuadraticNumber) -> RealQuadraticNumber:
        if not (r1.is_integral and r2.is_integral):
            raise ValueError(f"{r1=} and {r2=} must be integral elements of ğ(âˆšd).")
        if r1.d != r2.d:
            raise ValueError(f"{r1=} and {r2=} must belong to same ring of integers ğ“_ğ(âˆšd).")
        return r1 * r2.conjugate() - r1.conjugate() * r2

    
    def __init__(self, d: int, r1: RealQuadraticNumber, r2: RealQuadraticNumber) -> None:
        """
        """
        self.d = d
        self.a = r1
        self.r = r2

    @property
    def oriented_volume(self) -> RealQuadraticNumber:
        return type(self).orientation(self.a, self.r)
    
    @property
    def volume(self) -> RealQuadraticNumber:
        if self.oriented_volume < 0:
            return -self.oriented_volume
        return self.oriented_volume

    @property
    def D(self: typing.Self) -> int: # discriminant
        """
        Henri Cohen, A Course in Computation Algebraic Number Theory, Graduate Texts in Mathematics, Volume 138, Springer, 1996.
        p. 167:

        Proposition 4.4.5. The algebraic numbers ğ›¼1, ..., ğ›¼n form an integral basis
        if and only if they are algebraic integers and if d(ğ›¼1, ..., ğ›¼n) = d(K), where
        d(K) is the discriminant of K.
        """
        return self.d if self.d % 4 == 1 else 4 * self.d

    @property
    def norm(self) -> int:
        d = self.d
        if d % 4 == 1: # D = d
            D_sqrt = RealQuadraticNumber(d, 0, 1)
            return int(self.volume / D_sqrt)
        elif d % 4 in [2, 3]: # D = 4d
            D_sqrt = RealQuadraticNumber(d, 0, 2)
            return int(self.volume / D_sqrt)

    def __contains__(self, item: RealQuadraticNumber | Rational) -> bool:
        """
        a1 * r1 + a2 * r2 = r
        a1(x1 + y1âˆšd) + a2(x2 + y2âˆšd) = x + yâˆšd
        a1x1 + a2x2 + (a1y1 + a2y2)âˆšd = x + yâˆšd
        x1a1 + x2a2 = x
        y1a1 + y2a2 = y

        Cramer's rule:
        a1 = (x * y2 - x2 * y) / (x1y2 - x2y1) 
        a2 = (x1 * y - x * y1) / (x1y2 - x2y1)
        """
        if isinstance(item, Rational):
            item = RealQuadraticNumber(self.d, item, 0)
        if not item.is_integral:
            raise ValueError(f"{item=} must be an integral element of ğ(âˆšd).")
        a, r = self.a, self.r
        ax, ay, rx, ry, x, y = a.x, a.y, r.x, r.y, item.x, item.y
        D = ax * ry - rx * ay # nonzero by nonzero orientation

        a1 = Fraction(x * ry - rx * y, D)
        a2 = Fraction(ax * y - x * ay, D)
        if a1.denominator == 1 and a2.denominator == 1:
            return True
        return False
    
    def __le__(self, other: typing.Self) -> typing.Self:
        if self.a in other and self.r in other:
            return True
        return False
    
    def __lt__(self, other: typing.Self) -> typing.Self:
        if self.a in other and self.r in other and self != other:
            return True
        return False
    
    def __ge__(self, other: typing.Self) -> typing.Self:
        if other.a in self and other.r in self:
            return True
        return False
    
    def __gt__(self, other: typing.Self) -> typing.Self:
        if other.a in self and other.r in self and self != other:
            return True
        return False

    @classmethod
    def prime_ideal(cls, d: int, p: int, t_sgn: int = 1) -> typing.Self:
        """
        Henri Cohen, A Course in Computational Algebraic Number Theory, Prop. 5.1.4, p. 224.

        Let K = Q(âˆšD), ğ“_K = Z[Ï‰], with Ï‰ = (D + âˆšD)/2.

        (1) If (D/p)=0 then p ramifies and
            pZ_K = ğ”­Â²,  ğ”­ = âŸ¨p, Ï‰âŸ©  (unless p=2 and Dâ‰¡12 mod 16, then ğ”­=âŸ¨2,1+Ï‰âŸ©).
        (2) If (D/p)=â€“1 then p is inert and
            pZ_K itself is prime,  i.e.  (p) = âŸ¨p, pÂ·Ï‰âŸ©  (norm pÂ²).
        (3) If (D/p)=+1 then p splits and
            pZ_K = ğ”­â‚Â·ğ”­â‚‚,  
            ğ”­â‚ = âŸ¨p, Ï‰ â€“ (D + b)/2âŸ©,  
            ğ”­â‚‚ = âŸ¨p, Ï‰ â€“ (D â€“ b)/2âŸ©,  
            where bÂ² â‰¡ D (mod 4p) and you pick the sign of b via t_sgn=Â±1.
        """
        K = RealQuadraticField(d)
        D = K.D
        typ = K.prime_decomposition_type(p)

        # (1) ramified
        if typ == 0:
            if p == 2 and D % 16 == 12:
                return cls(p, 1 + K.omega)
            return cls(p, K.omega)
        # (2) inert: principal ideal (p) of norm p^2
        elif typ == -1:
            return cls(p, p * K.omega)
        # (3) split
        # solve b^2 â‰¡ D (mod 4p), pick Â± via t_sgn
        elif typ == 1:
            b = prime_numbers.solve_quadratic_congruence(D, 4 * p)
            r = K.omega - Fraction(D + t_sgn * b, 2)
            return cls(p, r)
        else:
            raise ArithmeticError("Supporting ingredients are broken.")